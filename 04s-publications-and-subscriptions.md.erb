---
title: Publicații și Subscrieri
slug: publications-and-subscriptions
date: 0004/01/02
number: 4.5
sidebar: true
contents: Vei învăța cum funcționează publicațiile și subscripțiile.|Vei învăța ce face pachetul Autopublish.|Vei vedea mai multe exemple de tertipuri de publicații.
paragraphs: 52
---

Publicațiile și subscrierile sunt unul din conceptele fundamentale în Meteor, dar pot fi complicate de înțeles la început.

Acest fapt a condus în trecut la niște neînțelegeri, cum ar fi conceptul nefondat că aplicațiile Meteor nu sunt sigure, sau că acestea nu se pot descurca cu cantități mari de date.

Un motiv pentru care oamenii sunt derutați de aceste concepte inițial este "magia" pe care Meteor o face pentru noi. Deși aceasta este foarte folositoare, poate conduce la obfuscarea a ceea ce se întâmplă defapt în spatele scenei. Așa că, hai să dăm la o parte fumul si oglinzile și să vedem ce se întamplă cu adevărat.

### Metoda veche

Dar mai întâi, hai să ne uităm în trecut în 2011 când Meteor încă nu exista. Să zicem că vrei să construiești o aplicație Rails. Când un utilizator îți apeleaza site-ul, clientul (browserul) trimite o cerere aplicației, care rulează pe server.

Prima sarcină a aplicației este să își dea seama care este informația pe care utilizatorul are nevoie să o vadă. Aceasta ar putea să fie o pagină de căutare cu 12 rezultate, profilul de utilizator al Mariei, ultimele 20 de tweeturi ale lui Bob, și așa mai departe. Practic, îți poți închipui că aplicația joacă rolul unui bibliotecar care parcurge cotloanele în căutarea cărții cerute.

O dată ce informația a fost selectată, a doua sarcină a aplicației este transformarea acesteia în HTML curat (sau JSON în cazul unui API).

Păstrând metafora bibliotecii, aceasta ar fi împachetarea cărții pe care tocmai ce ai cumpărat-o și înmânarea acesteia într-o punguță. Aceasta este partea de "View" a paradigmei faimoase de Model-View-Controller.

În final, aplicația ia codul HTML și îl trimite browserului. Treaba aplicației s-a încheiat, și acum că toată treaba este în afara mânuțelor ei virtuale poate să se relaxeze liniștită, cu o bere rece eventual, până la venirea următoarei cereri.

### Metoda Meteor

Să trecem în revistă ce face Meteor așa de special prin comparație. După cum am văzut, cheia inovației din Meteor este că în timp ce o aplicație Rails trăiește **numai pe server**, o aplicație Meteor include o componentă client-side care rulează **și pe client** (browserul).

<%= diagram "client-server", "Trimiterea spre client a unei submulțimi din baza de date", "pull-right" %>

Asta este ca bibliotecarul care nu doar că îți găsește cartea corectă, dar mai și vine cu tine până acasă ca să ți-o citească înainte să te culci (mda, analogia e cam ciudată).

Această arhitectură îi permite lui Meteor să facă foarte multe chestii, cea mai importantă fiind principiul de [database everywhere](http://docs.meteor.com/#sevenprinciples). Pe scurt, Meteor va lua o submulțime a bazei tale de date și o va *copia pe client*. 

Aceasta conduce la două mari consecințe: mai întâi, în loc să trimiți cod HTML clientului, o aplicație Meteor va trimite **doar informație pură**, și va lăsa clientul să se descurce cu ea, după principiul ([data on the wire](http://docs.meteor.com/#sevenprinciples)). Apoi, vei putea să **accesezi informația instantaneu** fără să trebuiască să aștepți să trimiți și să se și întoarcă datele de la server, principiul de ([latency compensation](http://docs.meteor.com/#sevenprinciples)).

### Publicațiile

Baza de date a unei aplicații conține zeci de mii de documente, unele dintre ele putând fi și private sau sensibile. Așa că nu ne dorim să punem în oglindă întreaga bază de date în memoria clientului, pentru motive de securitate si de scalabilitate.

Așa că avem nevoie de o metodă prin care să îi zicem lui Meteor care **submulțime** a informației poate fi trimisă clientului, lucru care se poate realiza prin intermediul unei **publicații**.

Să ne întoarcem la Microscope. Iată toate postările aplicației noastre, în baza de date:

<%= diagram "collections-1", "Toate postările din baza de date.", "pull-center" %>

Deși nu avem această funcție în Microscope, să ne imaginăm că unele din postările noastre au fost marcate ca având limbaj abuziv. Deși ne dorim să le ținem în baza de date, nu dorim să le afișăm utilizatorilor (adică nu vrem să le trimitem clienților).

Primul pas este să îi zicem lui Meteor ce informație *ne dorim* să trimitem clientului. O să îi spunem lui Meteor că dorim să **publicăm** numai postări care nu sunt marcate cu "flag":

<%= diagram "collections-2", "Excluderea posturilor marcate cu 'flag'.", "pull-center" %>

Iată codul corespunzător, care s-ar afla pe server:

~~~js
// on the server
Meteor.publish('posts', function() {
  return Posts.find({flagged: false}); 
});
~~~

Acest cod se asigură că nu există **nicio metoda posibilă** prin care un client să obțină acces asupra unei postări marcate cu flag. Aceasta este metoda prin care te asiguri că o aplicație Meteor este sigură: publici clientului numai datele la care are voie să aibă acces.

<% note do %>

### DDP

La nivel fundamental, te poți gândi la sistemul de publicație/subscripție ca la un tub care transmite datele de pe colecția (sursă) de pe server la colecția (destinație) de pe client.

Protocolul care se vorbește prin acel tub se numește **DDP** (care înseamnă Distributed Data Protocol). Ca să afli mai mult despre DDP, poți să te uiți la [această înregistrare de la The Real-Time Conference](http://2012.realtimeconf.com/video/matt-debergalis) de Matt DeBergalis (unul din fondatorii Meteor), sau la [acest screencast](http://www.eventedmind.com/posts/meteor-subscriptions-and-ddp) de Chris Mather care explică acest concept mai în detaliu.

<% end %>

### Subscripția

Deși ne dorim să facem toate postările care nu au fost marcate cu flag clienților, nu putem să trimitem pur și simplu mii de postări în același timp. Avem nevoie de o metodă prin care să specificăm clienților care este submulțimea de date de care au nevoie la un anumit moment, și aici întră în scenă **subscripțiile**.

Toate datele la care ești subscris vor fi **oglindite** pe client mulțumită lui Minimongo, implementarea client-side de MongoDB a lui Meteor.

De exemplu, să zicem că ne aflăm pe pagina de profil a lui Bob Smith, și dorim să afișăm numai postările *lui*.

<%= diagram "collections-3", "Subscrierea la postările lui Bob le va oglindi pe client.", "pull-center" %>

Mai întâi, să ne extindem publicația ca să folosească un parametru adițional:

~~~js
// on the server
Meteor.publish('posts', function(author) {
  return Posts.find({flagged: false, author: author});
});
~~~

Apoi putem să definim acel parametru când când ne *subscriem* la acea publicație din codul aplicației noastre client:

~~~js
// on the client
Meteor.subscribe('posts', 'bob-smith');
~~~

Aceasta este metoda prin care poți să faci o aplicație Meteor să fie scalabilă pe partea de client; în loc să te subscrii la *toată* informația disponibilă, poți să alegi doar părțile care te interesează. În acest fel, eviți să supraîncarci memoria browserului indiferent cât de mare este baza de date de pe server.

### Finding

////

<%= diagram "collections-4", "Selecting a subset of documents on the client.", "pull-center" %>

////

~~~js
// on the client
Template.posts.helpers({
  posts: function(){
    return Posts.find(author: 'bob-smith', category: 'JavaScript');
  }
});
~~~

////

### Autopublish

////

////

<%= diagram "autopublish", "Autopublish", "pull-center"%>

////

////

////

### Publishing Full Collections

////

~~~js 
Meteor.publish('allPosts', function(){
  return Posts.find();
});
~~~

<%= diagram "fullcollection", "Publishing a full collection", "pull-center" %>

////

### Publishing Partial Collections

////

~~~js 
Meteor.publish('somePosts', function(){
  return Posts.find({'author':'Tom'});
});
~~~

<%= diagram "partialcollection", "Publishing a partial collection", "pull-center" %>

<% note do %>

### Behind The Scenes

////

////

////

////

- ////
- ////
- ////

////

<% end %>

### Publishing Partial Properties

////

////

~~~js
Meteor.publish('allPosts', function(){
  return Posts.find({}, {fields: {
    date: false
  }});
});
~~~

<%= diagram "partialproperties", "Publishing partial properties", "pull-center" %>

////

~~~js
Meteor.publish('allPosts', function(){
  return Posts.find({'author':'Tom'}, {fields: {
    date: false
  }});
});
~~~

### Summing Up

////

////

////
